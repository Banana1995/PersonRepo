# 迭代器模式详解

迭代器模式本质上是将存储数据的集合类的遍历功能与管理数据功能拆分开。若不拆分的话将导致集合类的方法太多，不符合单一职责原则。同时，会使得整个类变得异常的复杂。当将数据的管理功能与遍历功能拆分开之后，便可以遵循上面的原则，这就是迭代器模式为了解决的问题。

> 迭代器模式定义如下：
>
> 迭代器模式(Iterator Pattern)：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。

在迭代器模式的内部，其实也运用到了工厂模式的思想。可以将集合类看作是工厂类，迭代器类看作是产品类，一个具体工厂类型可以有生产多个具体的迭代器类型。

> 在迭代器模式结构图中包含如下几个角色：
>
> ● Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。
>
> ● ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。
>
> ● Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。
>
> ● ConcreteAggregate（具体聚合类）：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。

在具体迭代器与具体聚合类之间存在着一种关联的关系，迭代器类里面需要存一个具体聚合类的引用，以访问聚合类中的数据。我们可以使用内部类的设计来表达这种关系。内部类自动会关联到外部类上面。

关于迭代器模式的具体代码这里就不做展示了，可以参考hashMap源码等来看迭代器的实现。