# 深入理解泛型

## 类型擦除

Java的泛型本质是参数化类型，就是将数据类型做为一个参数，在使用的时候再指定它的具体类型。但是因为Java使用了类型擦除，所以这个参数只存在于编译期，在运行期JVM是并不知道泛型的存在。

![](Pic/微信截图_20180404211042.png)

上图运行结果可以看出，在JVM运行时将`new ArrayList<String>()`与`new ArrayList<Integer>()`看作是同一个class类。 

泛型参数会擦除到它的第一个边界。如果没有边界，则默认擦除到Object类。

## 泛型与数组

Java中不允许直接以这种方式创建泛型数组`List<String>[] c = new List<String>[3]` 。如果Java允许创建泛型数组则会产生一个下面的问题：

```java
List<String>[] lsa = new List<String>[10]; // Not really allowed.  实际上是不允许的
Object o = lsa;  //强转为Object类型
Object[] oa = (Object[]) o;  //强转为Object[]数组
List<Integer> li = new ArrayList<Integer>();  
li.add(new Integer(3));  
oa[1] = li; // Unsound, but passes run time store check 通过了存储校验  
String s = lsa[1].get(0); // Run-time error: ClassCastException.  产生类型强转异常
```

上面代码的最后一句会产生运行时异常。这是因为JVM进行类型擦除之后是不知道泛型信息的，而数组是有协变效应的。所以支持将不同数据类型的数据放入到`Object[]`类型的数组中，所以就会导致取出数据的时候产生`ClassCastException`。 在取出数据的时候，泛型可以使得编译期上述最后一行代码不需要进行类型强转也可以通过编译器的检查（这是泛型设计的作用之一），但是在实际运行过程中又产生了`ClassCastException` 异常，这违背了泛型的设计原则（在编译期不出现 `未经检查的转换` ，运行期就不会报出类型转换异常）。

Java允许创建无边界通配符类型的数组，如下：

```java
List<?>[] lsa = new List<?>[10]; // OK, array of unbounded wildcard type. 
Object o = lsa;
Object[] oa = (Object[]) o;
List<Integer> li = new ArrayList<Integer>();
li.add(new Integer(3));
oa[1] = li; // Correct. 
oa[2] = "123";//Object[]数组可以存储任意类型的对象数据
String s = (String) lsa[1].get(0); // Run time error, but cast is explicit. 
```

上述代码的最后一行也会产生运行期类型强转异常，但是使用类型通配符数组，在取出元素类型时，则需要显式的强转数据类型。这一点使得

> **协变：A是B的父类，并且A的容器也是B的容器的父类，则称之为协变。**

泛型是不支持协变的，但是支持“伪协变”，意思是指泛型本身不支持协变，但是可以通过设置上下边界来实现类似协变的特性。

## 桥方法



## ？与T的区别

- 如果类型参数在方法声明中只出现一次，可以用通配符代替它。
- 当一个泛型用来表达方法的两个参数之间的关系时，则需要应该使用T，如：

```java
public static <T> T autoConvertType(T obj)
{
     return(T)obj;
}
```

- ?表示不确定的类型，T表示一个固定的类型，可以作为一个变量类型在方法体的函数中调用，如：

```java
public static void printColl(ArrayList<T> al){  
        Iterator<T> it = al.iterator();  
        while(it.hasNext())  
        {  
            T t = it.next();  
            System.out.println(t.toString());  
        }  
}
```

## 为什么需要引入泛型

- **保证代码类型安全。**


在编译期不出现 `未经检查的转换` ，运行期就不会报出类型转换异常。

- **提高了代码可重用性**

在《Java核心技术》中对泛型的定义是：

> “泛型” 意味着编写的代码可以被不同类型的对象所重用。

在泛型中，可以将不同数据类型作为参数来使用，这就可以使得不同数据类型公用同一套代码，自然提升了代码的可重用性。

> 泛型接口比较实用的使用场景就是用作策略模式的公共策略

作为策略模式的公共策略，会被很多类实现，同时需要支持传入不同的数据类型作为参数。

```java
public interface Comparator {

    public int compare(T lhs, T rhs);

    public boolean equals(Object object);
}
```

泛型接口定义基本的规则，作为引用传递给客户端，这样就可以在运行的时候传入不同的策略实现类。

- **消除强制类型转换**


存储任意类型的数据在集合中，但是取出来的时候都是object类型，此时必须强转。使用了泛型之后，编译器会自动插入类型转换的代码。所见即所得，使用时直接得到目标类型。

- **为了创建容器类**

根据《Java 编程思想》中的描述，泛型出现的动机在于：

> 有许多原因促成了泛型的出现，而最引人注意的一个原因，就是为了创建容器类。

在《effective java》中也建议使用List来代替Array，因为List可以保证编译期的类型安全，而Array不能。

## 何时产生未经检查的异常



[**参考文章一**](https://segmentfault.com/a/1190000005337789)

[**参考文章二**](https://juejin.im/entry/584abdff61ff4b0058d50547#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4) 