准备公司 ： 有赞 蘑菇街 丁香园 网易 挖财 阿里

目录：

# 一、Java

##基础

1. “static” 关键字是什么意思？

在Java里可以 override private 或 static 的方法吗？

static 关键字表示，访问这个成员**变量**或**方法**时，**不获取**它属于的**类 ** **实例**   。

Java 里的 static 方法**不能被 override**，因为 **override** 的**机制**是**运行时**(runtime)的**动态绑定**，而 **static **方法是在**编译时静态绑定**的。static方法与任何类的**具体实例无关**，因此无法应用继承的概念。

2. 在静态方法里可以访问非静态变量吗?

Java 中的 **static 变量**归相应的**类所有**，它的值对于类的所有实例都是相同的。**static 变量**是在 JVM加载类的时候**初始化**的。如果代码试图访问**非静态的变量**，而且不是通过类的实例去访问，编译器会报错，因为这些非静态变量还没有被创建呢，并且它们没有与实例相关联。

3. 静态变量和实例变量的区别？

Java 中的 **static 变量**归相应的**类所有**，它的值对于类的所有实例都是相同的。**static 变量**是在 JVM 加载类的时候**初始化**的。如果代码试图访问非静态的变量，而且不是通过类的实例去访问，编译器会报错，因为这些非静态变量还没有被创建呢，并且它们没有与实例相关联。

4. 传引用和传值

当对象通过**传值**调用时，传递的是这个**对象**的一个**拷贝**。因此，即使函数修改这个对象，也不会影响原对象的值。

当对象通过**传引用**调用时，对象本身没有被传递，而传递的是**对象**的一个**引用，**会**反映**到任何出现这**原对象**的地方。

5. Java 异常处理

**Java中的两种异常是什么?它们之间的区别?** 
Java有两种类型的异常:checked与unchecked(检查与未检查) 异常. 如果unchecked异常可能会在方法或构造函数的执行时被抛出从而蔓延到方法或构造函数的外部, 它们也不需要要在方法或构造函数中声明throws子句. 然而, checked异常必须通过方法或构造函数的throws子句声明.

6. Java中异常与错误的区别?

Exception和Error都是Throwable类的子类.Exception用于用户程序需要捕获的异常条件. Error定义了用户程序不可预见的异常

7. throw与throws的区别 ?

```
throws是用来声明一个方法可能抛出的所有异常信息
throw则是指抛出的一个具体的异常类型。
通常在一个方法（类）的声明处通过throws声明方法（类）可能抛出的异常信息，而在方法（类）内部通过throw声明一个具体的异常信息。
```

8. 异常处理中finally语句块的重要性?

不管程序是否发生了异常, finally语句块都会被执行. 甚至当没有catch声明但抛出了一个异常时, finally语句块也会被执行. 最后要说一点: finally语句块通常用于释放资源, 如I/O缓冲区, 数据库连接等等.

9. 异常被处理后异常对象会发生什么?

异常对象会在下次gc执行时被回收.

10. 怎样区分finally语句块与finalize()方法?

不管是否抛出异常finally语句块都会被执行, 它通常用于**释放**程序持有的**资源**.**finalize**是Object**类**中的一个**protected方法**, 当一个对象被**gc**回收**前**它会被**jvm调用**.

11. this()与super()的区别？

this()指向当前类引用的对象。super()指向当前类父类引用

12. java作用域public ,private ,protected 及不写时的区别 

作用域 当前类 同一package 子孙类 其他package

public √ √ √ √

protected √ √ √ ×

friendly √ √ × ×

private √ × × ×

13. 多态：OverLoading 和 Overriding 的区别？

方法的重写Overriding和重载Overloading是Java多态性的不同表现。

重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。OverLoading重载一个类中的多态性让类用统一方式处理不同类型数据。多个同名方法，具有不同的参数个数或参数类型。各方法返回类型不一定相同Overriding 重写父类与子类之间的多态表现。子类可以继承父类的方法，如需要修改则用重写。子类自定定义其方法和父类有相同名称、参数和返回类型，该方法被重写。这样访问子类该方法，会屏蔽父类方法。如果需要在子类该方法访问父类，则用super关键字。

14. Final类有什么特点？

final:能修饰类,方法,属性。

final修饰类时：该类不能被继承。

final修饰方法时：该方法不能被重写。

final修饰类的成员属性时：声明时就要赋值，或者在构造方法中给它赋值。

final修饰类的属性时：必须在声明时赋值。

final修饰局部变量：如果在声明时没有赋值，则在后面的代码中可以有一次给它赋值的机会，一旦赋值则该变量的值不可更改。

final修饰的变量是引用类型时指引用不能更改，引用指向的对象的属性值是可以更改的。

17）Java 中应该使用什么数据类型来代表价格？([答案](http://javarevisited.blogspot.sg/2012/02/java-mistake-1-using-float-and-double.html))
如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。

18）怎么将 byte 转换为 String？([答案](http://javarevisited.blogspot.sg/2014/08/2-examples-to-convert-byte-array-to-String-in-Java.html))
可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。

19）Java 中怎样将 bytes 转换为 long 类型？
这个问题你来回答 :-)

20）我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？
是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 128。

21）存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么？如 C = (C) B；([answer](http://javarevisited.blogspot.sg/2012/12/what-is-type-casting-in-java-class-interface-example.html)答案)

22）哪个类包含 clone 方法？是 Cloneable 还是 Object？([答案](http://javarevisited.blogspot.sg/2015/01/java-clone-tutorial-part-2-overriding-with-mutable-field-example.html))
java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。

23）Java 中 ++ 操作符是线程安全的吗？(答案) 

不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。

24）a = a + b 与 a += b 的区别(答案)
+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是 a += b 没问题，如下：
byte a = 127;
byte b = 127;
b = a + b; // error : cannot convert from int to byte
b += a; // ok
（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）

25）我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗？([答案](http://java67.blogspot.com/2014/11/how-to-convert-double-to-long-in-java-example.html))
不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。

26）3*0.1 == 0.3 将会返回什么？true 还是 false？(答案)
false，因为有些浮点数不能完全精确的表示出来。

27）int 和 Integer 哪个会占用更多的内存？(答案)
Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。

28）为什么 Java 中的 String 是不可变的（Immutable）？([answer](http://java67.blogspot.sg/2014/01/why-string-class-has-made-immutable-or-final-java.html)答案)
Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。更详细的内容参见答案。

29）我们能在 Switch 中使用 String 吗？([answer](http://javarevisited.blogspot.sg/2011/08/string-switch-case-jdk7-example.html)答案)
从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。

30）Java 中的构造器链是什么？([answer](http://java67.blogspot.sg/2012/12/how-constructor-chaining-works-in-java.html)答案)
当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。
82）在多线程环境下，SimpleDateFormat 是线程安全的吗？([答案](http://javarevisited.blogspot.sg/2012/03/simpledateformat-in-java-is-not-thread.html))
不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。

83）Java 中如何格式化一个日期？如格式化为 ddMMyyyy 的形式？([答案](http://javarevisited.blogspot.com/2011/09/convert-date-to-string-simpledateformat.html))
Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。

84）Java 中，怎么在格式化的日期中显示时区？([答案](http://java67.blogspot.sg/2013/01/how-to-format-date-in-java-simpledateformat-example.html))

85）Java 中 java.util.Date 与 java.sql.Date 有什么区别？([答案](http://java67.blogspot.sg/2014/02/how-to-convert-javautildate-to-javasqldate-example.html))

86）Java 中，如何计算两个日期之间的差距？([程序](http://javarevisited.blogspot.sg/2015/07/how-to-find-number-of-days-between-two-dates-in-java.html))

87）Java 中，如何将字符串 YYYYMMDD 转换为日期？([答案](http://java67.blogspot.sg/2014/12/string-to-date-example-in-java-multithreading.html))

**序列化？** 

序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。
序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。

##  集合

**1.** **“你知道 HashMap 的工作原理吗？” “你知道 HashMap 的 get ()方法的工作原理吗？”**

　　“HashMap 是基于 hashing 的原理，我们使用 put (key， value)存储对象到 HashMap 中，使用 get (key)从 HashMap 中获取对象。当我们给 put ()方法传递键和值时，我们先对键调用 hashCode ()方法，返回的 hashCode 用于找到 bucket 位置来储存 Entry 对象。”这里关键点在于指出，HashMap 是在 bucket 中储存键对象和值对象，作为 Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在 bucket 中存储值的话，你将不会回答如何从 HashMap 中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道 hashing 以及 HashMap 的工作原理。但是这仅仅是故事的开始，当面试官加入一些 Java 程序员每天要碰到的实际场景的时候，错误的答案频现。

2.**“当两个对象的 hashcode 相同会发生什么？”**

从这里开始，真正的困惑开始了，一些面试者会回答因为 hashcode 相同，所以两个对象是相等的，HashMap 将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有 equals ()和 hashCode ()两个方法，并告诉他们两个对象就算 hashcode 相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为 hashcode 相同，所以它们的 bucket 位置相同，‘碰撞’会发生。因为 HashMap 使用 LinkedList 存储对象，这个 Entry (包含有键值对的 Map.Entry 对象)会存储在 LinkedList 中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是 HashMap 的处理方法。

**3.“如果两个键的 hashcode 相同，你如何获取值对象？”**

面试者会回答：当我们调用 get ()方法，HashMap 会使用键对象的 hashcode 找到 bucket 位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个 bucket，他给出答案:将会遍历 LinkedList 直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到 HashMap 在 LinkedList 中存储的是键值对，否则他们不可能回答出这一题。

　　其中一些记得这个重要知识点的面试者会说，找到 bucket 位置之后，会调用 keys.equals ()方法去找到 LinkedList 中正确的节点，最终找到要找的值对象。完美的答案！

　　许多情况下，面试者会在这个环节中出错，因为他们混淆了 hashCode ()和 equals ()方法。因为在此之前 hashCode ()屡屡出现，而 equals ()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作 final 的对象，并且采用合适的 equals ()和 hashCode ()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的 hashcode，这将提高整个获取对象的速度，使用 String，Interger 这样的 wrapper 类作为键是非常好的选择。

**4.** **“如果 HashMap 的大小超过了负载因子(load factor)定义的容量，怎么办？”**除非你真正知道 HashMap 的工作原理，否则你将回答不出这道题。默认的负载因子大小为 0.75，也就是说，当一个 map 填满了 75% 的 bucket 时候，和其它集合类(如 ArrayList 等)一样，将会创建原来 HashMap 大小的两倍的 bucket 数组，来重新调整 map 的大小，并将原来的对象放入新的 bucket 数组中。这个过程叫作 rehashing，因为它调用 hash 方法找到新的 bucket 位置。

**5.“你了解重新调整 HashMap 大小存在什么问题吗？”**  

你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。　当重新调整 HashMap 大小的时候，确实存在条件竞争，因为如果两个线程都发现 HashMap 需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在 LinkedList 中的元素的次序会反过来，因为移动到新的 bucket 位置的时候，HashMap 并不会将元素放在 LinkedList 的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用 HashMap 呢？

**6.Java Collections框架的基本接口 ?** 

- **Collection**, 表示一组**对象**(元素).
- **Set**, 包含**非重复**元素的集合.
- **List**, 包含非重复元素的**有序集合**.
- **Map**, 包含非重复键的**键值对**的对象

**7.为什么Collection没有继承Cloneable和Serializable接口 ?** 

Collection接口描述的是由**元素组成**的**对象组**. Collection的每一个具体实现可以选择自己的方式来管理元素. 一些集合允许存在**重复键,**另一些则不允许.当处理**实际实现**时复制和序列化的语义和效果才会起作用. 因此, 集合类的**具体实现**应该**决定**它们将怎样被**复制**和**序列化**.

**8.什么是Iterator(叠代器) ?** 

**Iterator接口**提供了许多能够**叠代**集合的**方法**.每个java集合(Collection)都含有一个返回**Iterator实例**的iterator方法. 叠代器在叠代过程中能够移除底层集合中的元素.
**Iterator 和ListIterator之间的不同 ?**

- Iterator能够遍历**Set**和**List**集合, 而ListIterator只能用来遍历**List**.
- Iterator只能**正向**遍历集合, 而ListIterator可以**双向遍历List**.
- ListIterator实现了Iterator接口并提供了额外的功能, 例如**添加**元素, **替换**元素, 取得**上一个**或上一个元素索引, 等等.

**9.fail-fast与fail-safe的区别?**

Iterator的**fail_safe特性**是对底层集合的**拷贝**进行操作, 因此对集合的任何改变都不会有影响. java.util包下的所有集合类是**fail-fast**的, 但java.util.**concurrent**包下的集合类是**fail-safe**的. **fail-fast叠代器**会抛出**ConcurrentModificationException**, 而**fail-safe叠代器不会**抛出这种异常.
**10.Java中的 HashMap 是怎么工作的?** 
Java 中的 HashMap 是用来**存储键值对**的。 HashMap 需要一个 **hash 函数**，它使用**hashCode **和 **equals **方法，来进行 collection 中元素的**保存**和**查找**。调用 **put**方法时，HashMap 会计算**键(key)**的 **hash **值，然后将**键值对**存到 collection 的适当**索引**下。如果键已经存在，那么相应的值会更新。HashMap的重要特征主要有它的**容量**，**装载因子**(load factor)和**容量扩充**(threshold resizing)。
**11.HashMap是如何实现的？ Map的内部实现**
hashMap 本质就是链表+数组，只不过数组的每个元素是一个链表， 链表的节点就是 k-v 对。每次put(k, v) 时，按 hash(k) ,计算数组下表，然后在该处增加一个节点而已。一般情况下map的size>数组大小*饱和因子时，会做一个扩容的操作，扩容一般为大于原容量的最小的2的n次方，扩容会重做整个散列数组+链表，代价很大。使用hashmap时最好指定需要的容量大小
**12. hashCode() 和 equals() 方法重要性何在 ?** 
Java中的 HashMap 使用 hashCode 和 equals 方法来**确定键值对**的**索引**。根据键去**查询**对应的值时，同样会用到这两个方法。如果这两个方法没有正确实现，两个不同的键可能会产生相同的 hash 值，因此会被 collection 认为是相同的。并且，这两个方法在**检测重复**时也会用到。因此，这两个方法都要正确实现，对 **HashMap**的**正确性**和**效率**都至关重要。
**13.HashMap与HashTable之间有哪些不同？**

HashMap、HashTable这两个类都实现了Map接口，因此有些非常相似的特征，但他们在以下特性中又有所不同：**HashMap**的key与value都**允许null**值的存在，而**HashTable**则既**不允许**key为**null**，也不允许value为null。**HashTable**是线程**同步**的，而HashMap则不是。因此，在**单线程**环境下**HashMap**是首选，而HashTable更适合在多线程环境下使用。**HashMap**提供了它键的**set集合**，因此Java程序可以通过set进行迭代。因此，**HashMap**是**快速失败**的。另一方面，**HashTable**提供了它**键**的**枚举**。**HashTable**类被当做**遗留类.**

**14.Array与ArrayList间有什么不同？与ArrayList相比你什么时候会用Array？**

Array与ArrayList类在以下特性中有所区别：**Arrays**可以包含**基础数据**类型或者**对象**，而**ArrayList**只能包含**对象**。**Arrays**有**固定长度**，而**ArrayList**长度则是**动态**的。**ArrayList**类提供了**更多**的**方法**和**特性**，比如addAll,removeAll,iterator,等等对于一个**基础数据类型**的**动态**list，集合框架使用了自动装箱去减少编码的工作。但针对**固定长度**的的**基础数据**类型，这种方法会使得它们变得**更慢**。

**15.ArrayList与LinkedList间有什么不同？**

ArrayList、LinkedList这两个类都实现了**List接口**，但他们以下特性中又有所不同：ArrayList是基于**索引**的**数据结构**，**底层**由**Array**支持实现。它提供了以时间复杂度为**O(1)**的性能随机**访问**它的元素，另一方面，**LinkedList**以**元素列表**的方式来存储它的数据，每一个元素与它前一个和后一个元素都是相连的。对元素**查询**操作的时间复杂度为**O(n)**.对元素的**插入**、**添加**、**移除**操作，与ArrayList相比，**LinkedList更快**，因为，当一个元素被**添加**到**集合内部**的任意位置时，**LinkedList不需要**重新**调整**数组**大小**或者**更新索引**。**LinkedList**比ArrayList**消耗**更多的**内存**，因为LinkedList中每一个**节点**都存储了**两个引用**，一个是它**前一个元素**，一个是它**后一个元素**

**16.Comparable 和 Comparator 接口分别是什么 ? 列出它们的区别。** 

Java 提供的 Comparable 接口，其中只包含一个方法，就是 **compareTo**。这个方法会比较两个对象，从而得出它们的顺序关系。具体来说，它会返回一个负整数，零，或一个正整数，分别表示传入的对象小于，等于或大于已有的对象。Java 提供的 Comparator 接口，包含两个方法，**compare **和 **equals **。compare 方法比较两个参数，得出它们的顺序关系。它会返回一个负整数，零，或一个正整数，分别表示第一个参数小于，等于或大于已有的对象。equals 方法有1个参数，它用来确定参数对象是否等于这个 camparator。这个方法仅在要比较的对象也是一个 comparator，同时它的序关系与这个 comparator 相同时，才会返回 true。
**17.Java Priority Queue是什么?** 
PriorityQueue是一个基于**优先级堆**的**无界队列**，它的元素都以他们的**自然顺序有序**排列。在它创建的时候，我们可以可以提供一个比较器(**Comparator**)来负责PriorityQueue中**元素**的**排序**。PriorityQueue**不允许null**元素，不允许不提供自然排序的对象，也不允许没有任何关联Comparator的对象。最后，PriorityQueue**不是线程安全**的，在执行入队和出队操作它需要O(log(n))的时间复杂度。
**18. 关于Big-O符号你了解些什么？你能针对不同数据结构举些例子吗？** 
Big-O符号简单描述了，在一种数据结构中随着元素的不断增加，在最坏的情况下，一个算法的**扩展**或者**执行能力**有多好。**Big-O**符号还可以用来描述其他的行为，比如**内存消耗**。由于collection集合下的类实际上都是数据结构，我们通常用**Big-O**符号来选择基于**时间**、**内存**、**性能**前提下的最好实现去使用。Big-O符号能就大量数据的性能给出一个很好的指示。
**19. 如何权衡有序数组和无序数组 ?** 
**有序数组**最关键的优势在于**搜索**的时间复杂度为 **O(log n)**，而无序数组的时间复杂度是 **O (n)**。**有序数组**的劣势就在于**插入**操作的时间复杂度为 **O(n)**，因为较高值的元素需要挪动位置腾出空间给新元素。与之不同的是，**无序数组**的**插入**操作的时间复杂度为 **O(1)**。
有哪些关于 Java 集合框架的最佳实践？基于应用的需求来选择使用正确类型的集合，这对性能来说是非常重要的。例如，如果元素的**大小**是**固定**的，并且知道**优先级**，我们将会使用一个 **Array**，而不是 ArrayList。一些集合类允许我们指定他们的初始容量。因此，如果我们知道存储数据的大概数值，就可以避免重散列或者大小的调整。总是使用**泛型**来保证**类型安全**，**可靠性**和**健壮性**。同时，使用泛型还可以避免运行时的 ClassCastException。在 **Map **中使用 Java Development Kit (JDK) 提供的不可变类作为一个 key，这样可以避免 **hashCode** 的实现和我们自定义类的 **equals **方法。应该**依照接口**而不是实现来**编程**。**返回零长度**的**集合**或者**数组**，而不是返回一个 null ，这样可以**防止底层集合**是**空**的。
**20.Enumeration 和 Iterator 接口有什么不同 ?**

**Enumeration **跟 **Iterator **相比较**快**两倍，而且**占用**更**少**的**内存**。但是，**Iterator**相对于 **Enumeration **更**安全**，因为其他线程不能修改当前迭代器遍历的集合对象。同时，**Iterators 允许**调用者从**底层集合**中**移除**元素，这些 Enumerations 都没法完成。
**21.HashSet 和TreeSet 有什么不同?** 
HashSet 是用一个 **hash 表**来实现的，因此，它的元素是**无序**的。添加，删除和 HashSet 包括的方法的持续时间复杂度是 **O(1)**。另一个方面，**TreeSet **是用一个**树形结构**实现的，因此，它是**有序**的。添加，删除和 TreeSet 包含的方法的持续时间复杂度是 **O(logn)**。
**22. List、Set、Map 和 Queue 之间的区别(答案)** 
List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。

49）poll() 方法和 remove() 方法的区别？
poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。

50）Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？([答案](http://javarevisited.blogspot.sg/2013/10/what-is-priorityqueue-data-structure-java-example-tutorial.html))
PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。

51）ArrayList 与 LinkedList 的不区别？([答案](http://java67.blogspot.sg/2012/12/difference-between-arraylist-vs-LinkedList-java.html))
最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。更多细节的讨论参见答案。

52）用哪两种方式来实现集合的排序？([答案](http://java67.blogspot.sg/2012/07/sort-list-ascending-descending-order-set-arraylist.html))
你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。

53）Java 中怎么打印数组？([answer](http://java67.blogspot.sg/2014/03/how-to-print-array-in-java-example-tutorial.html)答案)
你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。

54）Java 中的 LinkedList 是单向链表还是双向链表？(答案)
是双向链表，你可以检查 JDK 的源码。在 [Eclipse](http://res.importnew.com/eclipse)，你可以使用快捷键 Ctrl + T，直接在编辑器中打开该类。

55）Java 中的 TreeMap 是采用什么树实现的？(答案)
Java 中的 TreeMap 是使用红黑树实现的。

56) Hashtable 与 HashMap 有什么不同之处？([答案](http://java67.blogspot.sg/2012/08/5-difference-between-hashtable-hashmap-Java-collection.html))
这两个类有许多不同的地方，下面列出了一部分：
a) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。
b）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。
c）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。
更多的不同之处参见答案。

57）Java 中的 HashSet，内部是如何工作的？([answer](http://java67.blogspot.sg/2014/01/how-hashset-is-implemented-or-works-internally-java.html)答案)
HashSet 的内部采用 HashMap来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。

58）写一段代码在遍历 ArrayList 时移除一个元素？([答案](http://javarevisited.blogspot.sg/2014/01/ow-to-remove-objects-from-collection-arraylist-java-iterator-traversing.html))
该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段[示例代码](http://java67.blogspot.com/2015/10/how-to-solve-concurrentmodificationexception-in-java-arraylist.html)，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。

59）我们能自己写一个容器类，然后使用 for-each 循环码？
可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。

60）ArrayList 和 HashMap 的默认大小是多数？([答案](http://javarevisited.blogspot.sg/2014/07/java-optimization-empty-arraylist-and-Hashmap-cost-less-memory-jdk-17040-update.html))

在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段：

```java
// from ArrayList.java JDK 1.7
privatestaticfinalintDEFAULT_CAPACITY = 10;
//from HashMap.java JDK 7
staticfinalintDEFAULT_INITIAL_CAPACITY = 1<< 4; // aka 16
```

61）有没有可能两个不相等的对象有有相同的 hashcode？
有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。

62）两个相同的对象会有不同的的 hash code 吗？
不能，根据 hash code 的规定，这是不可能的。

63）我们可以在 hashcode() 中使用随机数字吗？([答案](http://javarevisited.blogspot.sg/2011/10/override-hashcode-in-java-example.html))
不行，因为对象的 hashcode 值必须是相同的。参见答案获取更多关于 Java 中重写 hashCode() 方法的知识。64）Java 中，Comparator 与 Comparable 有什么不同？([答案](http://java67.blogspot.sg/2013/08/difference-between-comparator-and-comparable-in-java-interface-sorting.html))
Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。

65）为什么在重写 equals 方法的时候需要重写 hashCode 方法？([答案](http://javarevisited.blogspot.sg/2015/01/why-override-equals-hashcode-or-tostring-java.html))
因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。

##IO/NIO实现原理，设计模式

1. AIO 和 NIO 有什么区别？

Java NIO ： **同步非阻塞**，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
Java AIO(NIO.2) ： **异步非阻塞**，服务器实现模式为一个有效请求一个线程，客户端的**I/O请求**都是由**OS**先完成了再**通知服务器**应用去**启动线程**进行处理。

2. IO流整体机构

用的是装饰模式，装饰模式有四个角色，分别是通用接口、本原、抽象装饰、具体装饰，因为是将本原聚合到了装饰中，所以可以将本原或装饰通过构造子注入到另一个装饰，多个装饰可以随意的组合，形成一个综合的功能对象。

io流分为输入流及输出流，输入流是文件到内存，输出流是内存到文件。

流分为低层流及高层流，在实例化高层流时必须通过构造子将低层流注入到高层流中。输入流通用的方法是read(),read(char[]),read(byte[]),readline。

输出流的通用方法是write(int),write(byte[]),write[char[]],print("string")。 当读取一个文件时，对于以字节/字节数组,字符/字符数组读取的结束条件是!=-1,对于以字符串读取的结束条件是!=null。

对于有缓存的输出时，要想写入到文件必须flush或close。

IO 是 Java 面试中一个非常重要的点。你应该很好掌握 Java IO，NIO，NIO2 以及与操作系统，磁盘 IO 相关的基础知识。下面是 Java IO 中经常问的问题。

66）在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？

67）Java 中怎么创建 ByteBuffer？

68）Java 中，怎么读写 ByteBuffer ？

69）Java 采用的是大端还是小端？

70）ByteBuffer 中的字节序是什么？

71）Java 中，直接缓冲区与非直接缓冲器有什么区别？([答案](http://javarevisited.blogspot.sg/2015/08/difference-between-direct-non-direct-mapped-bytebuffer-nio-java.html))

72）Java 中的内存映射缓存区是什么？([answer](http://javarevisited.blogspot.sg/2012/01/memorymapped-file-and-io-in-java.html)答案)

73）socket 选项 TCP NO DELAY 是指什么？

74）TCP 协议与 UDP 协议有什么区别？([answer](http://javarevisited.blogspot.com/2014/07/9-difference-between-tcp-and-udp-protocol.html)答案)

75）Java 中，ByteBuffer 与 StringBuffer有什么区别？(答案)

## 多线程 并发

第一题：线程的基本概念、线程的基本状态及状态之间的关系？

第二题：线程与进程的区别？这个题目问到的概率相当大，计算机专业考研中也常常考到。要想全部答出比较难。第三题：多线程有几种实现方法，都是什么？

第四题：多线程同步和互斥有几种实现方法，都是什么？我在参加2011年迅雷校园招聘时的一面和二面都被问到这个题目，回答的好将会给面试成绩加不少分。

第五题：多线程同步和互斥有何异同，在什么情况下分别使用他们？举例说明。

第六题:  生产者消费者问题

这是一个非常经典的多线程题目，题目大意如下：有一个生产者在生产产品，这些产品将提供给若干个消费者去消费，为了使生产者和消费者能并发执行，在两者之间设置一个有多个缓冲区的缓冲池，生产者将它生产的产品放入一个缓冲区中，消费者可以从缓冲区中取走产品进行消费，所有生产者和消费者都是异步方式运行的，但它们必须保持同步，即不允许消费者到一个空的缓冲区中取产品，也不允许生产者向一个已经装满产品且尚未被取走的缓冲区中投放产品。

第七题:  读者写者问题

这也是一个非常经典的多线程题目，题目大意如下：有一个写者很多读者，多个读者可以同时读文件，但写者在写文件时不允许有读者在读文件，同样有读者读时写者也不能写。

**多线程** 

1. java中有几种方法可以实现一个线程？

答：在Java中实现一个线程有两种方法，第一是实现Runnable接口实现它的run（）方法，第二种是继承Thread类，覆盖它的run（）方法。这两种方法的区别是，如果你的类已经继承了其它的类，那么你只能选择实现Runnable接口了，因为Java只允许单继承的。

常见错误：调用run()方法而非start()方法
创建并运行一个线程所犯的常见错误是调用线程的run()方法而非start()方法，如下所示：

```
Thread newThread = new Thread(MyRunnable());
newThread.run();
```

起初你并不会感觉到有什么不妥，因为run()方法的确如你所愿的被调用了。但是，事实上,run()方法并非是由刚创建的新线程所执行的，**而是被创建新线程的当前线程所执行了**。也就是被执行上面两行代码的线程所执行的。想要让创建的新线程执行run()方法，必须调用新线程的start方法。

2. 如何停止一个正在运行的线程？

答：当不阻塞时候设置一个标志位，让代码块正常运行结束并停止线程。

如果发生了阻塞，用interupt()方法，Thread.interrupt（）方法不会中断一个正在运行的线程。

3. notify()和notifyAll()有什么区别？

答：1）notify()和notifyAll()都是Object对象用于通知处在等待该对象的线程的方法。
2）void notify(): 唤醒一个正在等待该对象的线程。
3）void notifyAll(): 唤醒所有正在等待该对象的线程。
两者的最大区别在于：
notifyAll使所有原来在该对象上等待被notify的线程统统退出wait的状态，变成等待该对象上的锁，一旦该对象被解锁，他们就会去竞争。
notify他只是选择一个wait状态线程进行通知，并使它获得该对象上的锁，但不惊动其他同样在等待被该对象notify的线程们，当第一个线程运 行完毕以后释放对象上的锁，此时如果该对象没有再次使用notify语句，即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的 通知，继续处在wait状态，直到这个对象发出一个notify或notifyAll，它们等待的是被notify或notifyAll，而不是锁。

4. sleep()和 wait()有什么区别?
5. 什么是Daemon线程？它有什么意义？
6. java如何实现多线程之间的通讯和协作？

**锁** 

1. 什么是可重入锁（ReentrantLock）？
2. 当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？
3. synchronized和java.util.concurrent.locks.Lock的异同？
4. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？

**并发框架** 

1. SynchronizedMap和ConcurrentHashMap有什么区别？
2. CopyOnWriteArrayList可以用于什么应用场景？

**线程安全** 

1. 什么叫线程安全？servlet是线程安全吗?
2. 同步有几种实现方法？
3. volatile有什么用？能否用一句话说明下volatile的应用场景？
4. 请说明下java的内存模型及其工作流程。
5. 为什么代码会重排序？

**并发容器和框架** 

1. 如何让一段程序并发的执行，并最终汇总结果？
2. 如何合理的配置java线程池？如CPU密集型的任务，基本线程池应该配置多大？IO密集型的任务，基本线程池应该配置多大？用有界队列好还是无界队列好？任务非常多的时候，使用什么阻塞队列能获取最好的吞吐量？
3. 如何使用阻塞队列实现一个生产者和消费者模型？请写代码。
4. 多读少写的场景应该使用哪个并发容器，为什么使用它？比如你做了一个搜索引擎，搜索引擎每次搜索前需要判断搜索关键词是否在黑名单里，黑名单每天更新一次。

**Java中的锁** 

1. 如何实现乐观锁（CAS）？如何避免ABA问题？
2. 读写锁可以用于什么应用场景？
3. 什么时候应该使用可重入锁？
4. 什么场景下可以使用volatile替换synchronized？

**并发工具** 

1. 如何实现一个流控程序，用于控制请求的调用次数？

**答案** 

可以阅读以下参考资料，知道答案后可以在回复中交流

- [Java线程池的分析和使用](http://ifeve.com/java-threadpool/) [Java线程池](http://ifeve.com/thread-pools/)（第二题）
- [原子操作的实现原理](http://ifeve.com/atomic-operation/) （锁 第一题）
- [Java中的读写锁](http://ifeve.com/read-write-locks/)（锁 第二题）
- [如何设计客户端流控程序](http://ifeve.com/concurrency-practice-1/) （并发工具 第一题）

进程与线程的区别 ?
**进程**是一个**程序**的**执行**(即正在运行的程序), 然而**线程**是在进程中**独立**的**执行序列**. 一个进程可以包含很多线程. **线程**有时被称为**轻量级的进程**.

说下创建线程的不同方式. 你倾向于哪种方式并说明原因 ?
有三种创建线程的方式:

- **继承Thread类.**
- **实现Runnable接口**.
- 通过**Executor框架创建线程池**.

首选方式是**实现Runnable接口**, 因为它**不需要继承**Thread类. 当你的程序设计需要多继承时, 使用接口会有所帮助. 另外, **线程池效率**是很**高**的, 并且**实施**起来也很**简单**.

解释下可用的线程状态.
在执行期间, 线程会处于以下状态中的一种:

- Runnable: 线程已**准备就绪**, 但没有立即运行.
- Running: 处理器**正在执行**的线程代码.
- Waiting: 处于**阻塞**状态的线程, **等待**外部某种处理的结束.
- Sleeping: 被**强制休眠**的线程.
- Blocked on I/O: 等待**I/O**操作的**完成**.
- Blocked on Synchronization: 等待**取得线程锁**.
- Dead: 线程已经执行**结束**.

4.同步方法与同步块的区别 ?
在Java程序中, **每个对象都拥有一个锁**.**线程**可以通过使用**synchronized**关键字来**获取**一个**对象**上的**锁**. synchronized关键字可以用于**方法**级别(**粗粒度锁**)或**代码块**级别(**细粒度锁**).

在监视器中的线程同步是怎样发生的? 你可以使用哪些级别的同步 ?

监视器的功能是对它关联的**对象执行加锁**，**解锁**操作。 
程序要进行对象的同步，首先必须获得该对象关联的监视器，通过监视器来加锁解锁。 

JVM使用结合了监视器的锁. 监视器是一个**守护者**, 它**看管**一个**同步代码**的**序列**, 并且确保在一个时刻只能有一个线程执行同步代码片段.**每个监视器关联着一个对象引用**. 只能**有锁的线程**才可以执行**同步代码**.

什么是死锁 ?

当**两个进程相互等待对方**执行**完毕**时, 其结果是它们会永远等待下去.

怎样确保N个线程访问N个资源时不会发生死锁 ?

使用N个线程时一个非常简单的避免死锁的方法是为所有的**锁排序**, 并强制每个**线程**也按那种方式**排序**. 这样, 如果所有线程以相同的顺序锁定和解锁互斥资源就不会发生死锁了

**高并发，执行耗时短的任务，还有低并发，执行耗时长的任务，各自选取什么样的线程池会比较合理？为什么？如果业务场景是高并发，且任务耗时长时，有什么解决思路？**

线程池的关键点是：1、尽量减少线程切换和管理的开支； 2、最大化利用cpu。
对于1，要求线程数尽量少，这样可以减少线程切换和管理的开支；
对于2，要求尽量多的线程，以保证CPU资源最大化的利用。
所以对于任务耗时短的情况，要求线程尽量少，如果线程太多，有可能出现线程切换和管理的时间，大于任务执行的时间，那效率就低了；对于耗时长的任务，要分是cpu任务，还是io等类型的任务。如果是cpu类型的任务，线程数不宜太多；但是如果是io类型的任务，线程多一些更好，可以更充分利用cpu。
所以：
高并发，低耗时的情况：建议少线程，只要满足并发即可；例如并发100，线程池可能设置为10就可以
低并发，高耗时的情况：建议多线程，保证有空闲线程，接受新的任务；例如并发10，线程池可能就要设置为20；
高并发高耗时：1要分析任务类型，2增加排队，3、加大线程数

**有一个生成唯一串的需求，并发请求量非常大，该如何实现？**

唯一串的格式：集群编号+机器ip+jvm进程号+线程编号+时间+计数器

**sleep()和wait()的区别**

它们最大本质的区别是:sleep()不释放同步锁,wait()释放同步锁.

还有用法的上的不同是:sleep(milliseconds)可以用时间指定来使他自动醒过来,如果时间不到你只能调用interreput()来强行打断;wait()可以用notify()直接唤起.

1。这两个方法来自不同的类分别是Thread和Object

2。最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法

3。wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在 任何地方使用

synchronized(x){

x.notify()//或者wait()

}

4。sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常

1) 什么是线程？

线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。欲了解更多详细信息请[点击这里](http://java67.blogspot.com/2014/01/10-points-about-thread-and-javalangthread-in-java.html)。

2) 线程和进程有什么区别？

线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。

3) 如何在Java中实现线程？

在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。更多详细信息请[点击这里](http://javarevisited.blogspot.sg/2011/02/how-to-implement-thread-in-java.html).

4) 用Runnable还是Thread？

这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。更多详细信息请[点击这里](http://javarevisited.blogspot.sg/2012/01/difference-thread-vs-runnable-interface.html)。

6) Thread 类中的start() 和 run() 方法有什么区别？

这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。更多讨论请[点击这里](http://javarevisited.blogspot.sg/2012/03/difference-between-start-and-run-method.html)

7) Java中Runnable和Callable有什么不同？

Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。[我的博客](http://java67.blogspot.com/2013/01/difference-between-callable-and-runnable-java.html)有更详细的说明。

8) Java中CyclicBarrier 和 CountDownLatch有什么不同？

CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。[点此查看更多信息和示例代码](http://javarevisited.blogspot.com/2012/07/cyclicbarrier-example-java-5-concurrency-tutorial.html)。

9) Java内存模型是什么？

Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：

- 线程内的代码能够按先后顺序执行，这被称为程序次序规则。
- 对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。
- 前一个对`volatile`的写操作在后一个`volatile`的读操作之前，也叫`volatile`变量规则。
- 一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。
- 一个线程的所有操作都会在线程终止之前，线程终止规则。
- 一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。
- 可传递性

我强烈建议大家阅读《Java并发编程实践》第十六章来加深对Java内存模型的理解。

10) Java中的volatile 变量是什么？

volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。[点击这里](http://javarevisited.blogspot.com/2011/06/volatile-keyword-java-example-tutorial.html)查看更多volatile的相关内容。

11) 什么是线程安全？Vector是一个线程安全类吗？ （[详见这里](http://javarevisited.blogspot.sg/2011/09/difference-vector-vs-arraylist-in-java.html))

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。

12) Java中什么是竞态条件？ 举个例子说明。

竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理，详见[答案](http://javarevisited.blogspot.com/2012/02/what-is-race-condition-in.html)。

13) Java中如何停止一个线程？

Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。[点击这里](http://javarevisited.blogspot.com/2011/10/how-to-stop-thread-java-example.html)查看示例代码。

14) 一个线程运行时发生异常会怎样？

这是我在一次面试中遇到的一个[很刁钻的Java面试题](http://java67.blogspot.sg/2012/09/top-10-tricky-java-interview-questions-answers.html), 简单的说，如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。

15） 如何在两个线程间共享数据？

你可以通过**共享对象**来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。这篇教程[《Java线程间通信》](http://javarevisited.blogspot.sg/2013/12/inter-thread-communication-in-java-wait-notify-example.html)(涉及到在两个线程间共享对象)用wait和notify方法实现了生产者消费者模型。

16) Java中notify 和 notifyAll有什么区别？

这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。[我的博客](http://javarevisited.blogspot.com/2012/10/difference-between-notify-and-notifyall-java-example.html)有更详细的资料和示例代码。

17) 为什么wait, notify 和 notifyAll这些方法不在thread类里面？

这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。你也可以查看[这篇文章](http://javarevisited.blogspot.sg/2012/02/why-wait-notify-and-notifyall-is.html)了解更多。

18) 什么是ThreadLocal变量？

ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。查看[答案](http://javarevisited.blogspot.sg/2012/05/how-to-use-threadlocal-in-java-benefits.html)了解更多。

19) 什么是FutureTask？

在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。

20) Java中interrupted 和 isInterruptedd方法的区别？

interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用[静态方法](http://java67.blogspot.com/2012/11/what-is-static-class-variable-method.html)Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。

21) 为什么wait和notify方法要在同步块中调用？

主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。

22) 为什么你应该在循环中检查等待条件?

处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因，你可以在[Eclipse](http://res.importnew.com/eclipse)中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《[Effective Java](http://www.amazon.com/gp/product/B000WJOUPA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=B000WJOUPA&linkCode=as2&tag=job0ae-20)》这本书中的线程和同步章节。

23) Java中的同步集合与并发集合有什么区别？

同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。更多内容详见[答案](http://javarevisited.blogspot.com/2010/10/what-is-difference-between-synchronized.html)。

24） Java中堆和栈有什么不同？

为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。
更多内容详见[答案](http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html)。

25） 什么是线程池？ 为什么要使用它？

创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。更多内容详见[这篇文章](http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html)。

26） 如何写代码来解决生产者消费者问题？

在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，[这篇教程](http://javarevisited.blogspot.sg/2012/02/producer-consumer-design-pattern-with.html)有实现它。

27） 如何避免死锁？

[![deadlock in Java](https://note.youdao.com/yws/public/resource/1aa1883f5524c497744d6078589530b7/2658A1AC6A414F0596821241EDBC2AB9/B498B6A46FF84D8C98EA861DBBF4CDB3)](http://www.importnew.com/12773.html/deadlock-in-java)
Java多线程中的死锁
死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：

- 互斥条件：一个资源每次只能被一个进程使用。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
- 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。[这篇教程](http://javarevisited.blogspot.com/2010/10/what-is-deadlock-in-java-how-to-fix-it.html)有代码示例和避免死锁的讨论细节。

28) Java中活锁和死锁有什么区别？

这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。

29） 怎么检测一个线程是否拥有锁？

我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。你可以查看[这篇文章](http://javarevisited.blogspot.com/2010/10/how-to-check-if-thread-has-lock-on.html)了解更多。

30) 你如何在Java中获取线程堆栈？

对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。

31) JVM中哪个参数是用来控制线程的栈堆栈小的

这个问题很简单， -Xss参数用来控制线程的堆栈大小。你可以查看[JVM配置列表](http://javarevisited.blogspot.com/2011/11/hotspot-jvm-options-java-examples.html)来了解这个参数的更多信息。

32） Java中synchronized 和 ReentrantLock 有什么不同？

Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。你可以查看[这篇文章](http://javarevisited.blogspot.com/2013/03/reentrantlock-example-in-java-synchronized-difference-vs-lock.html)了解更多

33） 有三个线程T1，T2，T3，怎么确保它们按顺序执行？

在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。你可以查看[这篇文章](http://javarevisited.blogspot.sg/2013/02/how-to-join-multiple-threads-in-java-example-tutorial.html)了解更多。

34) Thread类中的yield方法有什么作用？

Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。[点击这里](http://java67.blogspot.sg/2012/08/difference-between-yield-and-wait.html)查看更多yield方法的相关内容。

35） Java中ConcurrentHashMap的并发度是什么？

ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。欲了解更多并发度和内部大小调整请阅读我的文章[How ConcurrentHashMap works in Java](http://javarevisited.blogspot.com/2013/02/concurrenthashmap-in-java-example-tutorial-working.html)。

36） Java中Semaphore是什么？

Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。更多详细信息请[点击这里](http://javarevisited.blogspot.com/2012/05/counting-semaphore-example-in-java-5.html)。

37）如果你提交任务时，线程池队列已满。会时发会生什么？

这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。

38) Java线程池中submit() 和 execute()方法有什么区别？

两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。更多详细信息请[点击这里](http://javarevisited.blogspot.sg/2013/07/how-to-create-thread-pools-in-java-executors-framework-example-tutorial.html)。

39) 什么是阻塞式方法？

阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。更多详细信息请[点击这里](http://javarevisited.blogspot.sg/2012/02/what-is-blocking-methods-in-java-and.html)。



43) 如何在Java中创建Immutable对象？

这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。我的文章[how to make an object Immutable in Java](http://javarevisited.blogspot.com/2013/03/how-to-create-immutable-class-object-java-example-tutorial.html)有详细的教程，看完你可以充满自信。

44） Java中的ReadWriteLock是什么？

一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。

45) 多线程中的忙循环是什么?

忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。你可以查看[这篇文章](http://java67.blogspot.com/2012/08/5-thread-interview-questions-answers-in.html)获得更多信息。

46）volatile 变量和 atomic 变量有什么不同？

这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。

47) 如果同步块内的线程抛出异常会发生什么？

这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在[finally block](http://javarevisited.blogspot.com/2012/11/difference-between-final-finally-and-finalize-java.html)里释放锁实现。

48） 单例模式的双检锁是什么？

这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。你可以查看[how double checked locking on Singleton works](http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html)这篇文章获得更多信息。

49） 如何在Java中创建线程安全的Singleton？

这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。你可以查看[这篇文章](http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html)获得更多信息。

50) 写出3条你遵循的多线程最佳实践

这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：

- 给你的线程起个有意义的名字。
  这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。
- 避免锁定和缩小同步的范围
  锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。
- 多用同步类少用wait 和 notify
  首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。
- 多用并发集合少用同步集合
  这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。我的文章[Java并发集合](http://javarevisited.blogspot.com/2013/02/concurrent-collections-from-jdk-56-java-example-tutorial.html)有更详细的说明。

51) 如何强制启动一个线程？

这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。

52) Java中的fork join框架是什么？

fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。你可以查看[这篇文章](http://javarevisited.blogspot.com/2011/09/fork-join-task-java7-tutorial.html)获得更多信息。

53） Java多线程中调用wait() 和 sleep()方法有什么不同？

Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。你可以查看[这篇文章](http://javarevisited.blogspot.com/2011/12/difference-between-wait-sleep-yield.html)获得更多信息。

1）Java 中能创建 volatile 数组吗？
能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。

2）volatile 能使得一个非原子操作变成原子操作吗？
一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。

3）volatile 修饰符的有过什么实践？
一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。

4）volatile 类型变量提供什么保证？([答案](http://java67.blogspot.sg/2012/08/what-is-volatile-variable-in-java-when.html))
volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。

5) 10 个线程和 2 个线程的同步代码，哪个更容易写？
从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。

6）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？([答案](http://javarevisited.blogspot.sg/2015/07/how-to-use-wait-notify-and-notifyall-in.html))
wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：

| 123456 | `// The standard idiom for using the wait method``synchronized``(obj) {``while``(condition does not hold)``obj.wait(); ``// (Releases lock, and reacquires on wakeup)``... ``// Perform action appropriate to condition``}` |
| ------ | ---------------------------------------- |
|        |                                          |

参见 [Effective Java](http://www.amazon.com/gp/product/B000WJOUPA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=B000WJOUPA&linkCode=as2&tag=job0ae-20) 第 69 条，获取更多关于为什么应该在循环中来调用 wait 方法的内容。

7）什么是多线程环境下的伪共享（false sharing）？
伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行，如下图所示：![img](https://note.youdao.com/yws/public/resource/1aa1883f5524c497744d6078589530b7/2658A1AC6A414F0596821241EDBC2AB9/B88FFDC87F0D4621B42D6046F30EE99B)

### 有经验程序员的 Java 面试题

伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审查代码，根据缓存行来调整你的数据结构。

8）什么是 Busy spin？我们为什么要使用它？
Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他CPU上运行就会丢失）。所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。

9）Java 中怎么获取一份线程 dump 文件？
在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java 应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。如果你使用Tomcat。

10）Swing 是线程安全的？([答案](http://javarevisited.blogspot.sg/2013/08/why-swing-is-not-thread-safe-in-java-Swingworker-Event-thread.html))
不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如 JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学习到更详细的内容。

11）什么是线程局部变量？([答案](http://javarevisited.blogspot.sg/2012/05/how-to-use-threadlocal-in-java-benefits.html))
线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。

12）用 wait-notify 写一段代码来解决生产者-消费者问题？([答案](http://java67.blogspot.sg/2012/12/producer-consumer-problem-with-wait-and-notify-example.html))
请参考答案中的示例代码。只要记住在同步块中调用 wait() 和 notify()方法，如果阻塞，通过循环来测试等待条件。

13) 用 Java 写一个线程安全的单例模式（Singleton）？([答案](http://javarevisited.blogspot.in/2012/12/how-to-create-thread-safe-singleton-in-java-example.html))
请参考答案中的示例代码，这里面一步一步教你创建一个线程安全的 Java 单例类。当我们说线程安全时，意思是即使初始化是在多线程环境中，仍然能保证单个实例。Java 中，使用枚举作为单例类是最简单的方式来创建线程安全单例模式的方式。

14）Java 中 sleep 方法和 wait 方法的区别？([答案](http://java67.blogspot.sg/2012/08/what-are-difference-between-wait-and.html))
虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。

15）什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？([答案](http://javarevisited.blogspot.sg/2013/03/how-to-create-immutable-class-object-java-example-tutorial.html))
不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。详情参见答案，一步一步指导你在 Java 中创建一个不可变的类。

16）我们能创建一个包含可变对象的不可变对象吗？
是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。



##Java内存模型 、JUC等

无

##JVM原理类加载器 JVM运行区

Java会不会内存泄露？怎样会泄露？

集合类，集合类仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。

比如类中的静态属性，全局性的map等即有静态引用或final一直指向它

什么是JVM? 为什么称Java为跨平台的编程语言?

Java虚拟机(Java Virtual Machine)是可以**执行**Java**字节码**的**虚拟机**，每个Java**源文件**将被编译成**字节码文件**，然后在JVM中**执行**。Java之所以**跨平台**，归功于Java虚拟机(JVM),因为JVM非常了解特定的**指令**的长度以及**底层硬件**平台的特殊性。

JDK和JRE之间的差异是什么？

Java运行环境(**Java Runtime Enviroment**) 是运行Java程序的**基本**的Java**虚拟机**，包括执行applet的浏览器插件。JDK (**Java Development Kit**) 是为了开发，编译和执行Java应用程序，针对Java的全功能的**软件开发包**，**包含**了**JRE**，**编译器和工具**(比如说 [JavaDoc](http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html) 和[Java Debugger](http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html))。

**垃圾回收器**

Java中垃圾回收的目的是什么, 它什么时候被使用 ?

垃圾回收用于**识别**和**丢弃**程序**不再需要**的**对象**, 以便**回收**和**复用资源**.

System.gc() 和Runtime.gc()方法用途?

这些方法用于**作用JVM**开始**垃圾回收**. 然而开始垃圾**回收**的**时机**是由**JVM决定**的.

finalize()什么时候被调用 ? 它的目的是什么 ?

finallize方法是在**释放**该对象**内存前**由**gc**(垃圾回收器)**调用**. 通常建议在这个方法中**释放**该对象持有的**资源.**

如果一个对象的引用被设置为null, gc会立即释放该对象的内存么?

不会, 这个对象将会在**下一次gc**循环中被**回收**.

Java堆的结构是什么 ? 堆中的Perm Gen(全称是Permanent Generation)空间是什么 ?

JVM有一个**运行时数据区**,即**堆**(heap).所有的**类实例**和**数组**的内存都是从**堆**中**分配**的. 它在JVM启动时被创建. 对象所占用的堆内存会被一个称为垃圾回收器的自动内存管理系统收回.

堆内存中包含活的和死的对象. 活的对象可以被程序访问并且不会被垃圾回收. 死的对象是那些**不会被程序访问**的, 但还没有被**垃圾回收器收回**的对象. 这种对象会占用堆内存空间直到最终被垃圾回收器收回.

Serial 垃圾回收器与 Throughput 垃圾回收器区别 ?

**Throughput**垃圾回收器使用**并行**版本的**新生代**回收器, 它用于中到**大型数据集**的应用. 另一方面, **Serial**回收器通常足以应对大多数的**小应用**(在现代处理器上不会超过约100MB的堆内存).

什么时候对象会被回收 ?
当当前**程序无法访问**到某个**对象**时，该对象将**被回收**.

垃圾回收发生在指定的JVM区域 ?
**垃圾回收**在 **PermGen **里发生。如果 PermGen满了或是到了瓶颈，就会触发完全回收。如果仔细 观察垃圾回收过程，会发现**PermGen**最后也被回收了. 这就是为什么要设置合理的PermGen大小以避免完全垃圾回收.

**JVM的结构和类加载原理**

马上拿起桌上的笔和纸，把虚拟机运行时包含的几个数据区和执行引擎画了下，包括方法区、虚拟机栈、本地方法栈、堆和程序计数器，然后介绍每个区域有什么作用，最后讲ClassLoader的类加载机制，还顺便说了下双亲委派机制。

**GC机制的巧妙**

我从两个方面说下自己的理解：一是Java的内存分配原理与C/C++不同，C/C++每次采用malloc或new申请内存时都要进行brk和mmap等系统调用，而系统调用发生在内核空间，每次都要中断进行切换，这需要一定的开销，而Java虚拟机是先一次性分配一块较大的空间，然后每次new时都在该空间上进行分配和释放，减少了系统调用的次数，节省了一定的开销，这有点类似于内存池的概念；二是有了这块空间过后，如何进行分配和回收就跟GC机制有关了，然后我详细介绍了GC原理、画图表示年轻代（Eden区和Survival区）、年老代、比例分配及为啥要这样分代回收（我认为巧妙就在于这里），有了GC基本结构后，我又详述了下GC是具体如何进行内存分配和垃圾回收的。

Java垃圾回收机制GC：

垃圾回收是一种动态存储管理技术，它自动地释放不再被程序引用的对象，按照特定的垃圾收集算法来实现资源自动回收的功能。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用，以免造成内存泄露。
When?CPU空闲或者内存不足的时候。

31）64 位 JVM 中，int 的长度是多数？
Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。

32）Serial 与 Parallel GC之间的不同之处？([答案](http://javarevisited.blogspot.sg/2011/04/garbage-collection-in-java.html))
Serial 与 Parallel 在GC执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行。

33）32 位和 64 位的 JVM，int 类型变量的长度是多数？(答案)
32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4 个字节。

34）Java 中 WeakReference 与 SoftReference的区别？([答案](http://javarevisited.blogspot.sg/2014/03/difference-between-weakreference-vs-softreference-phantom-strong-reference-java.html))
虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。

35）WeakHashMap 是怎么工作的？(答案)
WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。

36）JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？(答案)
当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。

37）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？([答案](http://javarevisited.blogspot.sg/2012/01/find-jvm-is-32-or-64-bit-java-program.html))
你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。

38）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？([答案](http://javarevisited.blogspot.sg/2013/04/what-is-maximum-heap-size-for-32-bit-64-JVM-Java-memory.html))
理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。

39）JRE、JDK、JVM 及 JIT 之间有什么不同？([答案](http://javarevisited.blogspot.sg/2011/12/jre-jvm-jdk-jit-in-java-programming.html))
JRE 代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。
[![JVM JRE JDK](https://note.youdao.com/yws/public/resource/1aa1883f5524c497744d6078589530b7/0A17D730BAEE4A06A18BFAFEBD0C0ABF/1451990027637306)](http://jbcdn2.b0.upaiyun.com/2015/11/4468a2440b48658c08acc50f15c3985b.jpg)

[JVM JRE JDK](http://jbcdn2.b0.upaiyun.com/2015/11/4468a2440b48658c08acc50f15c3985b.jpg)

3 年工作经验的 Java 面试题

40）解释 Java 堆空间及 GC？([答案](http://javarevisited.blogspot.sg/2011/05/java-heap-space-memory-size-jvm.html))
当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。
[![java_heaps_memory](https://note.youdao.com/yws/public/resource/1aa1883f5524c497744d6078589530b7/0A17D730BAEE4A06A18BFAFEBD0C0ABF/1451990027729930)](http://jbcdn2.b0.upaiyun.com/2015/11/7ce5bea27bd3671ceab81f17629b395b.jpg)

[java_heaps_memory](http://jbcdn2.b0.upaiyun.com/2015/11/7ce5bea27bd3671ceab81f17629b395b.jpg)

**JVM 底层面试题及答案** 

41）你能保证 GC 执行吗？(答案)
不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行。

42）怎么获取 Java 程序使用的内存？堆使用的百分比？
可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。

43）Java 中堆和栈有什么区别？([答案](http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html))
JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。
[![Difference between stack and heap memory in Java](https://note.youdao.com/yws/public/resource/1aa1883f5524c497744d6078589530b7/0A17D730BAEE4A06A18BFAFEBD0C0ABF/1451990027756784)](http://jbcdn2.b0.upaiyun.com/2015/11/1495374ba77fdf61435e38755773cc30.gif)

[Difference between stack and heap memory in Java](http://jbcdn2.b0.upaiyun.com/2015/11/1495374ba77fdf61435e38755773cc30.gif)

### 关于内存的的面试问题和答案

### Java 基本概念面试题

44）“a==b”和”a.equals(b)”有什么区别？([答案](http://javarevisited.blogspot.sg/2012/12/difference-between-equals-method-and-equality-operator-java.html))
如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。

45）a.hashCode() 有什么用？与 a.equals(b) 有什么关系？([答案](http://javarevisited.blogspot.sg/2011/10/override-hashcode-in-java-example.html))
hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。

46）final、finalize 和 finally 的不同之处？([答案](http://javarevisited.blogspot.sg/2012/11/difference-between-final-finally-and-finalize-java.html))
final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。

47）Java 中的编译期常量是什么？使用它又什么风险？
公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。

## GC



# 二、数据结构/算法

各种排序了解一下

# 三、网络 TCP UDP IP

# 四、数据库 Oracle SQL脚本 Redis

**数据库中内连接与外连接的区别？**

**inner join on ：对于左表的每一条记录和右表作乘积，如果满足on条件则加入结果集，最终的记录数>=0left join on ：对于左表的每一条记录和右表作乘积，如果不存在满足on条件的记录，则添加一条记录（需要返回的右表列以null表示），最终的记录数>=左表的记录数right join on ： 对于右表的每一条记录和左表作乘积，如果不存在满足on条件的记录，则添加一条记录（需要返回的左表列以null表示），最终的记录数>=右表的记录数**

**数据库事务是如何实现的?**

**Memcache与Redis的区别**

1、存储方式

- Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。
- Redis有部份存在硬盘上，这样能保证数据的持久性。

2、数据支持类型

- Memcache对数据类型支持相对简单。
- Redis有复杂的数据类型。字符串、哈希表、链表、集合、有序集合String、Hash、List、Set和Sorted Set

3、使用底层模型不同

- 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。
- Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

#五、J2EE

##  设计模式 Spring JDK

## Mybatis



## JDBC

什么是 JDBC ？JDBC是一个抽象层，允许用户在不同数据库间进行选择。JDBC使开发人员能够在Java中编写数据库应用程序，而不必让自己关心一个特定的数据库的底层细节。解释JDBC中驱动的作用。JDBC驱动提供了 对 JDBC API 所提供的抽象类 的 数据库供应商的特定实现。每个驱动必须提供java.sql包的以下的类实现：Connection,Statement,PreparedStatement,CallableStatement,ResultSet 和Driver。Class.forName 方法的目的是什么?此方法用于加载驱动程序，以建立与数据库的连接。与Statement相比PreparedStatement的优点?PreparedStatement是预编译的，因此它有更好的性能。另外，PreparedStatement可以被不同输入值的查询重用。CallableStatement的用途 ? 指出用于创建CallableStatement的方法.CallableStatement用于执行存储过程。存储过程由数据库保存并提供。存储过程可以根据用户的输入返回结果。强烈建议使用存储过程，因为它提供了安全性和模块化。准备CallableStatement的方法如下：CallableStament.prepareCall();连接池是什么 ?打开和关闭数据库连接时与数据库的交互需要付出很高的代价. 特别是当数据库客户端增长时，这个代价是相当高的，并且消耗了很多资源。数据库连接池中的连接在应用服务器启动时被创建并在池中进行管理。一个连接请求由池中的数据库连接提供。当连接结束后，请求会被放回池中以供以后重用。

**JDBC如何做事务处理？**

在jdbc api中，可以通过调用setAutoCommit(false) 来禁止自动提交事务。然后就可以把多条更新数据库的sql语句做为一个事务，在所有操作完成之后，调用commit（）来进行整体提交。倘若其中一项 sql操作失败，就不会执行commit（）方法，而是产生相应的sqlexception，此时就可以捕获异常代码块中调用rollback（）方法撤消事务。

## Spring 

**事务的隔离级别**

![img](https://note.youdao.com/yws/public/resource/1aa1883f5524c497744d6078589530b7/775D6C275CDE4270BBD1E674AB3C6525/E72C9DD35C0146189836CDE1F7AEFBAD)

****

**为什么要使用Spring？**

针对容器框架来说，ejb与spring了，ejb这个容器包含太多组建了。而且这些组建，都是必须的，并且十分复杂，难以理解。尤其是ejb2.0中太多。在大部分项目开发中只需要几个简单的组建就可以了，而切无法根据自己的需求，切换相同功能，而不同实现的组建。
这样无法达到一种默认的标准。就是轻，轻，好维护，升级，开发也简单。
spring的基本容器只有ioc，默认的aop实现是基于ioc实现的，然后spring，直对其他框架，库，标准进行兼容。这样有很强大的灵活性，扩展性，维护性
spring体系更加完善，包括data模块，test模块

spring对其他的一些优秀框架的整合，也使得spring脱颖而出。

使用Spring第一是使用它的IOC功能，在解耦上达到了配置级别。第二是使用它对数据库访问事务相关的封装。第三就是各种其他组件与Spring的融合

**如何减少上下文切换？**

上下文切换又分为2种：让步式上下文切换和抢占式上下文切换。前者是指执行线程主动释放CPU，与锁竞争严重程度成正比，可通过减少锁竞争来避免；后者是指线程因分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占，一般由于线程数大于CPU可用核心数引起，可通过调整线程数，适当减少线程数来避免

**你觉得Spring有什么缺点吗**

Spring的缺点不多，如果非要找几个的话，我觉得是

1. 开发效率。Spring这种通过XML配置的方式，很容易配置错误，影响开发效率。当然有些配置可以使用Anotation配置，但是不能完全替代XML，比如包扫描，创建多个实例都需要通过XML来配置。Spring的这种设计是一种通过XML来编程的方式。
2. 测试效率。配置多的话，容器启动时间比较长，影响测试效率。所有有些测试，我们尽量都不启动Spring容器。
3. 有一定的上手成本。

**Spring MVC请求处理流程**

① 整个过程开始于客户端发送一个HTTP请求；② DispatcherServlet接收这个请求后，并将请求的处理工作委托给具体的处理器（Handler），后者负责处理请求执行相应的业务逻辑。在这之前，DispatcherServlet必须能够凭借请求信息（URL或请求参数等）按照某种机制找到请求对应的处理器，DispatcherServlet是通过垂询HandlerMapping完成这一工作的；③ 当DispatcherServlet从HandlerMapping中得到当前请求对应的处理器后，它就将请求分派给这个处理器。处理器根据请求的信息执行相应的业务逻辑，一个设计良好的处理器应该通过调用Service层的业务对象完成业务处理，而非自己越俎代庖。
④ 处理器完成业务逻辑的处理后将返回一个ModelAndView给DispatcherServlet，ModelAndView包含了视图逻辑名和渲染视图时需要用到的模型数据对象；⑤ 由于ModelAndView中包含的是视图逻辑名，DispatcherServlet必须知道这个逻辑名对应的真实视图对象，这项视图解析的工作通过调用ViewResolver来完成；⑥ 当得到真实的视图对象后，DispatcherServlet将请求分派给这个View对象，由其完成Model数据的渲染工作；⑦ 最终客户端得到返回的响应，这可能是一个普通的HTML页面，也可能是一个Excel电子表格、甚至是一个PDF文档等不一而足的视图形式，Spring的视图类型是异常丰富和灵活的。

#### 什么是控制反转(IOC)?什么是依赖注入?

控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过”依赖注入”实现的。

控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。

依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？

在Java中依然注入有以下三种实现方式：

- 构造器注入
- Setter方法注入
- 接口注入

IOC,依赖倒置的意思,
所谓依赖，从程序的角度看，就是比如A要调用B的方法，那么A就依赖于B，反正A要用到B，则A依赖于B。
所谓倒置，你必须理解如果不倒置，会怎么着，因为A必须要有B，才可以调用B，如果不倒置，意思就是A主动获取B的实例：B b = new B()，这就是最简单的获取B实例的方法（当然还有各种设计模式可以帮助你去获得B的实例，比如工厂、Locator等等），然后你就可以调

**什么是AOP?有什么作用？**

AOP(Aspect-Oriented Programming)其实是OOP(Object-Oriented Programing)
思想的补充和完善。我们知道，OOP引进"抽象"、"封装"、"继承"、"多态"等概念,对万事万物进行抽象和封装，来建立一种对象的层次结构，它强调了
一种完整事物的自上而下的关系。但是具体细粒度到每个事物内部的情况，OOP就显得无能为力了。比如日志功能。日志代码往往水平地散布在所有对象层次当
中，却与它所散布到的对象的核心功能毫无关系。对于其他很多类似功能，如事务管理、权限控制等也是如此。这导致了大量代码的重复，而不利于各个模块的重
用。 而AOP技
术则恰恰相反，它利用一种称为"横切"的技术，能够剖解开封装的对象内部，并将那些影响了多个类并且与具体业务无关的公共行为 封装成一个独立的模块（称
为切面）。更重要的是，它又能以巧夺天功的妙手将这些剖开的切面复原，不留痕迹的融入核心业务逻辑中。这样，对于日后横切功能的编辑和重用都能够带来极大
的方便。 AOP技术的具体实现，无非也就是通过动态代理技术或者是在程序编译期间进行静态的"织入"方式。下面是这方面技术的几个基本术语： 1、join point（连接点）：是程序执行中的一个精确执行点，例如类中的一个方法。它是一个抽象的概念，在实现AOP时，并不需要去定义一个join point。 2、point cut（切入点）：本质上是一个捕获连接点的结构。在AOP中，可以定义一个point cut，来捕获相关方法的调用。 3、advice（通知）：是point cut的执行代码，是执行“方面”的具体逻辑。 4、aspect（方面）：point cut和advice结合起来就是aspect，它类似于OOP中定义的一个类，但它代表的更多是对象间横向的关系。 5、introduce（引入）：为对象引入附加的方法或属性，从而达到修改对象结构的目的。有的 OP工具又将其称为mixin。

# 六、 操作系统 Linux/Shell

```
◆ 安装和登录命令：login、shutdown、halt、reboot、install、mount、umount、chsh、
exit、last；

◆ 文件处理命令：file、mkdir、grep、dd、find、mv、ls、diff、cat、ln；

◆ 系统管理相关命令：df、top、free、quota、at、lp、adduser、groupadd、kill、
crontab；

◆ 网络操作命令：ifconfig、ip、ping、netstat、telnet、ftp、route、rlogin、rcp、
finger、mail、 nslookup；

◆ 系统安全相关命令：passwd、su、umask、chgrp、chmod、chown、chattr、sudo ps、
who；

◆ 其它命令：tar、unzip、gunzip、unarj、mtools、man、unendcode、uudecode。
```

# 七、自我介绍 & 项目经验 



八、关注什么新技术，有什么爱好

阶段方向 ：多线程 并发 →JVM原理→ J2EE→ 项目经验
为了做 Java EE 的朋友，这里列出了一些 web 开发的特定问题，你们可以用来准备 JEE 部分的面试：

10 大 Spring 框架面试题及答案([参见](http://javarevisited.blogspot.sg/2011/09/spring-interview-questions-answers-j2ee.html))
10 个非常好的 XML 面试问题（Java 程序员）([参见](http://javarevisited.blogspot.sg/2013/01/10-xml-interview-questions-and-answers.html))
20 个非常好的设计模式面试问题([参见](http://java67.blogspot.com/2012/09/top-10-java-design-pattern-interview-question-answer.html))
10个最流行的 Struts 面试题（Java 开发者）([参见](http://javarevisited.blogspot.sg/2011/11/struts-interview-questions-answer-j2ee.html))
20 个 Tibco Rendezvous 及 EMS 的面试题([更多](http://javarevisited.blogspot.sg/2011/01/tibco-rv-interview-question-as-part.html))
10 个最频繁被问到的 Servlet 面试问题及答案([参见](http://javarevisited.blogspot.sg/2011/09/servlet-interview-questions-answers.html))
20 个 jQuery 面试问题（Java Web 开发者）([列表](http://javarevisited.blogspot.sg/2015/02/top-16-jquery-interview-questions.html))
10 个非常好的 Oracle 面试问题（Java 开发者）([参见](http://javarevisited.blogspot.sg/2012/12/top-10-oracle-interview-questions-and-answers-database-sql.html))
10 大 来自 J2EE 面试中的 JSP 问题([更多](http://javarevisited.blogspot.sg/2011/10/jsp-interview-questions-answers-for.html))
12 个很好的 RESTful Web Services 面试问题([参见](http://javarevisited.blogspot.sg/2012/01/rest-web-services-framework-interview.html))
10 大 EJB 面试问题及答案([参见](http://javarevisited.blogspot.sg/2012/03/top-10-ejb-interview-question-and.html))
10 大 JMS 及 MQ 系列面试题及答案([列表](http://javarevisited.blogspot.sg/2014/03/top-10-websphere-mq-series-interview-questions-answers-active-rabbit.html))
10 个非常好 Hibernate 面试问题（Java EE 开发者）([参见](http://javarevisited.blogspot.sg/2013/05/10-hibernate-interview-questions-answers-java-j2ee-senior.html))
10 个非常好的 JDBC 面试题（Java 开发者）([参见](http://javarevisited.blogspot.sg/2012/12/top-10-jdbc-interview-questions-answers.html))
15 个 Java NIO 和网络面试题及答案([参见](http://javarevisited.blogspot.sg/2014/08/socket-programming-networking-interview-questions-answers-Java.html))
10 大 XSLT 面试题及答案([更多](http://javarevisited.blogspot.sg/2013/05/10-xslt-or-xml-xsl-transformation-interview-questions-answers-java.html))
15 个来自 Java 面试的数据结构和算法问题([参见](http://javarevisited.blogspot.com/2013/03/top-15-data-structures-algorithm-interview-questions-answers-java-programming.html))
10 大 Java 面试难题及答案([参见](http://java67.blogspot.com/2012/09/top-10-tricky-java-interview-questions-answers.html))
40 个核心 Java 移动开发面试题及答案([列表](http://java67.blogspot.com/2015/03/top-40-core-java-interview-questions-answers-telephonic-round.html))

**1.先了解那个公司做啥的**

**2.了解那个岗位的职责和要求**

**3.整理自己的项目经验和知识体系**

**4.补习一下基础知识**

**5.整理着装**

**四个阶段：**

**1.基础知识**

**2.项目经验**

**3.是否负责过项目，带过团队**

4.杂七杂八比如关注什么新技术，有什么爱好，之类的



# 其他

**你Java学的怎么样？**

还可以，有研究过部分JDK源码，比如常用的集合类如HashMap/Hashtable、ArrayList/LinkedList、Vector等，IO 和并发包。看过周志明《》及《》。

**阿里面试题－你做过最得意的项目是什么？****B2P金融平台 ****初级：经验考察肯定是首要的，还有一个是考察在过去的工作里，是否有专注去专研过东西。******76）Java 中，编写多线程程序的时候你会遵循哪些最佳实践？([答案](http://javarevisited.blogspot.com/2015/05/top-10-java-multithreading-and.html))
这是我在写Java 并发程序的时候遵循的一些最佳实践：
a）给线程命名，这样可以帮助调试。
b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。
c）如果可以，更偏向于使用 volatile 而不是 synchronized。
d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。
e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。77）说出几点 Java 中使用 Collections 的最佳实践(答案)
这是我在使用 Java 中 Collectionc 类的一些最佳实践：
a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是 Vector。
b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。
c）使用接口代表和访问集合，如使用List存储 ArrayList，使用 Map 存储 HashMap 等等。
d）使用迭代器来循环集合。
e）使用集合的时候使用泛型。78）说出至少 5 点在 Java 中使用线程的最佳实践。([答案](http://java67.blogspot.com/2014/01/10-points-about-thread-and-javalangthread-in-java.html))
这个问题与之前的问题类似，你可以使用上面的答案。对线程来说，你应该：
a）对线程命名
b）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。
c）使用线程池79）说出 5 条 IO 的最佳实践(答案)
IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践：
a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。
b）使用 NIO 和 NIO2
c）在 finally 块中关闭流，或者使用 try-with-resource 语句。
d）使用内存映射文件获取更快的 IO。80）列出 5 个应该遵循的 JDBC 最佳实践([答案](http://javarevisited.blogspot.sg/2012/08/top-10-jdbc-best-practices-for-java.html))
有很多的最佳实践，你可以根据你的喜好来例举。下面是一些更通用的原则：
a）使用批量的操作来插入和更新数据
b）使用 PreparedStatement 来避免 SQL 异常，并提高性能。
c）使用数据库连接池
d）通过列名来获取结果集，不要使用列的下标来获取。81）说出几条 Java 中方法重载的最佳实践？([答案](http://javarevisited.blogspot.sg/2013/01/java-best-practices-method-overloading-constructor.html))
下面有几条可以遵循的方法重载的最佳实践来避免造成自动装箱的混乱。
a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参数。
b）不要重载参数数量一致，而只是参数顺序不同的方法。
c）如果重载的方法参数个数多于 5 个，采用可变参数



**如何实现微信“附近的人”功能？**

客户端固定时间发送经纬度（x,y）到服务器s，服务器存储每个登陆的用户的经纬度到表t中，表t按照经纬度分表，将地图分成一个个的小格子。以用户当前经纬度画圆，半径视需求，然后找出经纬度落在这个圆里面的点。



**什么是类的反射机制？**

JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。在Java设计模式中代理模式，代理类反射实现接口。

89）如何测试静态方法？(答案)
可以使用 PowerMock 库来测试静态方法。90）怎么利用 JUnit 来测试一个方法的异常？([答案](http://javarevisited.blogspot.sg/2013/04/JUnit-tutorial-example-test-exception-thrown-by-java-method.html))91）你使用过哪个单元测试库来测试你的 Java 程序？(答案)92）@Before 和 @BeforeClass 有什么区别？([答案](http://javarevisited.blogspot.sg/2013/04/JUnit-tutorial-example-test-exception-thrown-by-java-method.html))
93）怎么检查一个字符串只包含数字？([解决方案](http://java67.blogspot.com/2014/01/java-regular-expression-to-check-numbers-in-String.html))94）Java 中如何利用泛型写一个 LRU 缓存？(答案<)95）写一段 Java 程序将 byte 转换为 long？(答案)95）在不使用 StringBuffer 的前提下，怎么反转一个字符串？([解决方案](http://java67.blogspot.com/2012/12/how-to-reverse-string-in-java-stringbuffer-stringbuilder.htm))97）Java 中，怎么获取一个文件中单词出现的最高频率？([解决方案](http://java67.blogspot.com/2015/10/java-program-to-find-repeated-words-and-count.html))98）如何检查出两个给定的字符串是反序的？([解决方案](http://javarevisited.blogspot.sg/2013/03/Anagram-how-to-check-if-two-string-are-anagrams-example-tutorial.html))99）Java 中，怎么打印出一个字符串的所有排列？([解决方案](http://javarevisited.blogspot.com/2015/08/how-to-find-all-permutations-of-string-java-example.html))100）Java 中，怎样才能打印出数组中的重复元素？([解决方案](http://javarevisited.blogspot.com/2015/06/3-ways-to-find-duplicate-elements-in-array-java.html))101）Java 中如何将字符串转换为整数？([解决方案](http://java67.blogspot.com/2015/08/2-ways-to-parse-string-to-int-in-java.html))102）在没有使用临时变量的情况如何交换两个整数变量的值？([解决方案](http://java67.blogspot.com/2015/08/how-to-swap-two-integers-without-using.html))

#经验 

\1. 打印list 全部元素，并找到其中某个元素删除。要求：所有元素都遍历完

\2. String 作为方法参数

\3. People.name

\4. 数据库 - 数据索引

\5. hashmap concurrenthashmap 区别 
\6. 为啥haspmap是不同步的，不安全的 数据结构为啥导致不安全

为什么hashmap 的get put 方法，为什么不是线程安全？

\7. 悲观锁 和 乐观锁

\8. 多线程

\9. java回调机制

\10. 看过什么源码 --- 分析

Java研发岗位

初面：应用卡leader

\1. 排序快排 堆排序

\2. final 方法 类 变量 jvm

\3. jvm 相关

4.集合 hashmap treemap

\5. string stringbuilder stringbuffer

\6. javabean

\7. http协议

\8. servlet 源码

\9. tomcat

\11. 继承 多态

\12. 抽象类 和 接口

\13. pojo

\10. 你的规划

建议：

\1. 业务同等重要 业务抽出来核心就是牛逼架构

\2. 多了解底层，多多了解过程 来龙去脉

\3. 底层数据结构

复面：管钱leader

\1. 认证我简历上的

\2. 实习项目 模版引擎

\3. SpringMVC 机制

### CRLF的意思

就是回车(CR, ASCII 13, \r) 换行(LF, ASCII 10, \n)。

\5. 项目中的web并发 （问了 分布式中处理乐观锁）

编程题：

\1. log 文件设计（IO、策略模式）

\2. SQL编写

\3. 异步多线程

建议：

\1. 操作系统 文件系统

**你酷爱着计算机以及互联网技术，热衷于解决挑战性的问题，追求极致的用户体验； **

**或许，你痴迷于数据结构和算法，热衷于ACM，常常为看到“accept”而兴奋的手足舞蹈；**

或许，你熟悉Unix/Linux/Win32环境下编程，并有相关开发经验，熟练使用调试工具，并熟悉Perl，Python，shell等脚本语言；

 或许，你熟悉网络编程和多线程编程，对TCP/IP，HTTP等网络 协议有很深的理解，并了解XML和HTML语言；

 或许，你热衷于数据库技术，能够熟练编写SQL脚本，有MySql 或Oracle应用开发经验；

 或许，你并不熟悉；，更精通C，C++，PHP，.NET等编程语言中的一种或几种，但你有良好和快速的学习能力； 

有可能，你参加过大学生数学建模竞赛，“挑战杯”，机器人足球比赛等；

也有可能，你在学校的时候作为骨干参与学生网站的建设和开发； 

# 项目经验

对照简历完善业务逻辑。

提供过什么解决方案。

业务如何保证事务。

# 介绍项目

1. 自我介绍

   我叫高满意，从16年毕业加入恒生电子以来，一直从事Java后台开发的工作。主要负责的是交易银行产品的后台公共模块和供应链融资业务。使用的是tiny+Spring+Mybatis的框架，tiny是公司内部的框架，其实是类似于Spring的，可以理解为SSM框架。

2. 最近熟悉的做过的项目介绍

    入职恒生以来一直做得是交易银行产品公共模块，业务方面最熟悉的是近半年负责的供应链融资方面的后台开发。

3. 对于Spring的了解？用过Spring哪些东西？

   项目中用到过Spring 的Aop做过公共角色校验、日志打印等。使用Spring的IOC做过依赖注入。

   - AOP的原理和使用

     动态代理 jdk代理和cglib代理

   - IOC的原理和使用

     控制反转依赖注入

   - Spring事务实现

4. 多线程用过吗？

   用过！

5. Linux使用过么？

   查看cpu运行命令 top命令

   查找文件命令详见Linux操作培训

6. 对应用服务器了解嘛？

   weblogic服务部署。

7. 关于中间件使用

   - Spring整合MongoDB

   - 为什么使用MongoDB

     因为MongoDB是面向文档的数据库，不是关系型数据库。它采用分布式部署，可以获得更好的扩展性。加入了MongoDB之后，可以将一部分数据转移到MongoDB上做中间存储，减轻数据库的压力。

     将工作流数据当做内嵌数组存进MongoDB里，工作流流转过程中的状态数据不断变换，一次查询就可以将每次的变更数据都查询出来，非常的方便。

     MongoDB三大特性：灵活文档模型 + 高可用复制集 + 可扩展分片集群

     应用不需要复杂的事务支持；新应用，需求会变，数据模型无法确定，想快速迭代开发。

   - Tiny集成Redis客户端

   - zookeeper实现了分布式流水和分布式锁

   - RabbitMq实现消息队列

   ​

8. 使用过的设计模式

   - 模板方法模式：业务模板
   - 单例模式
   - 命令模式：异步命令
   - 工厂模式：Redis的FactoryBean工厂
   - 代理模式：SpringAOP
   - 观察者模式：RabbitMQ发布订阅

9. 线程池配置多少个线程合适？

   - IO密集型任务：配置CPU核数*2（因为执行IO时大部分线程阻塞，不占用CPU，可以让CPU来执行更多的线程）
   - CPU计算密集型任务：配置CPU核数+1（计算密集时，只能让CPU每个核都在工作，这样使得每个线程都在执行当中。）

